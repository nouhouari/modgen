<#macro underlinesToCamelCase inString><#local strArray = inString?split("_")><#list strArray as item><#if item?index == 0>${item}<#else>${item?cap_first}</#if></#list></#macro>
<#assign aDateTime = .now>
<#assign aDate = aDateTime?date>
/*
 * Author   : Nourreddine HOUARI <nourreddine.houari@>
 *     Koneru, Venkaiah Chowdary <VenkaiahChowdary.Koneru@> 
 *
 * Date     :  ${aDate?string.medium} 
 * 
 * File     :  ${entity.name?cap_first}ServiceImpl.java 
 * 
 * Copyright (c) ${aDate?string.yyyy} houari_nourreddine Sdn Bhd, All rights reserved.                   
 */
 package ${package};

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import ${entityPackage}.${entity.name?cap_first}${entity_suffix};
import ${entityPackage}.EntityState;
<#list entity.attributes as attribute>
<#if attribute.reference>
import ${protoPackage}.${attribute.type};
import ${entityPackage}.${attribute.type}${entity_suffix};
<#elseif attribute.enumerate>
import ${entityPackage}.${attribute.type?cap_first};
</#if>
</#list> 

import ${protoPackage}.*;
import ${protoPackage}.${entity.name?cap_first};
import ${protoPackage}.${entity.name?cap_first}SaveResult;
import ${protoPackage}.${entity.name?cap_first}SaveResult.${entity.name?cap_first}SaveStatusEnum;
import ${protoPackage}.${entity.name?cap_first}Query;
import ${repositoryPackage}.${entity.name?cap_first}${entity_repository_suffix};
import ${repositoryPackage}.${entity.name?cap_first}Specification;
import ${repositoryPackage}.${entity.name?cap_first}QuickSearchSpecification;
import ${package}.${entity.name?cap_first}Service;
import ${package}.GenericEntityServiceImpl;
import ${validationPackage}.PotValidationUtil;
import ${transformerPackage}.${entity.name?cap_first}${entity_suffix}ProtoMapperImpl;
<#assign myHash = { }>
<#list entity.relations as relation>
<#if !myHash[relation.model.name]??>
<#assign myHash=myHash + { relation.model.name: 0 }>
import ${transformerPackage}.${relation.model.name?cap_first}${entity_suffix}ProtoMapperImpl;
import ${protoPackage}.${relation.model.name};
import ${entityPackage}.${relation.model.name}${entity_suffix};
</#if>
</#list>

import com.sicpa.ptf.audit.trail.Auditor;
import com.sicpa.ptf.common.messages.Audit;
import com.sicpa.ptf.extension.schema.support.service.SchemaDao;
import com.sicpa.ptf.extension.schema.support.service.SchemaEntity;

import javax.validation.Validator;
import rx.subjects.PublishSubject;
<#if entity.hasAnnotation("PUBLISH") || entity.hasAnnotation("SUBSCRIBE")>
import rx.Observable;
</#if>

<#function convertJavaToObjectType type>
 <#if type == "String">
   <#return "String">
 <#elseif type == "long" || type== "Long">
    <#return "Long">
 <#elseif type == "int" || type== "Integer">
    <#return "Integer">   
 </#if>
</#function> 

/**
 * THIS FILE IS AUTOMATICALLY GENERATED
 *     >> DO NOT EDIT MANUALLY <<
 * <br><br>
 * Generated by : ${generator}<br>
 * Version      : ${version}<br>
 * Date         : ${aDate?string.medium}<br>
 * <br>
 * @author Nourreddine HOUARI <nourreddine.houari@>
 * @author Koneru, Venkaiah Chowdary <VenkaiahChowdary.Koneru@> 
 *
 */
@Service
@Transactional(readOnly=true)
public class ${entity.name?cap_first}ServiceImpl extends GenericEntityServiceImpl<${entity.name?cap_first}, ${entity.name?cap_first}${entity_suffix}> implements ${entity.name?cap_first}Service {

  //PRIVATE MEMBERS
  @Autowired
  private ${entity.name?cap_first}${entity_repository_suffix} repository;

  /**
   * JSR-303 / JSR-349 validator
   */
  @Autowired
  private Validator validator;
  
  <#if entity.hasAnnotation("EXTENDABLE")>
  @Autowired
  private SchemaDao schemaDao;
  </#if>

  /*
   * Validation listeners.
   */
  private List<${entity.name?cap_first}ValidationListener> validationListeners = new ArrayList<>();
  
  /*
   * Query constraint listeners.
   */
  private ${entity.name?cap_first}QueryConstraintListener queryConstraintListener;

  /*
   * Service listeners.
   */
  private List<${entity.name?cap_first}ServiceListener> serviceListeners = new ArrayList<>();
  <#assign myHash = { }>
  <#list entity.attributes as attribute>
    <#if attribute.reference>
    <#if !myHash[attribute.model.name]??>
    <#assign myHash=myHash + { attribute.model.name: 0 }>
  @Autowired
  private ${attribute.type?cap_first}Service ${attribute.type?uncap_first}Service;
  @Autowired
  private PublishSubject<AddLink${entity.name?cap_first}To${attribute.name?cap_first}Request> addLink${entity.name?cap_first}To${attribute.name?cap_first}Subject;
 </#if>
    </#if>
 </#list>
 
 <#list entity.relations as relation>
 <#if !myHash[relation.model.name]??>
 <#assign myHash=myHash + { relation.model.name: 0 }>
 
  @Autowired
  private ${relation.model.name?cap_first}${entity_suffix}ProtoMapperImpl ${relation.model.name?uncap_first}${entity_suffix}ProtoMapperImpl;
 
  @Autowired
  private ${relation.model.name?cap_first}Service ${relation.model.name?uncap_first}Service;
 </#if>
 </#list>

  <#if entity.hasAnnotation("PUBLISH")>
  // Published entity
  private final PublishSubject<${entity.name?cap_first}${entity_suffix}> newVersionPublishSubject = PublishSubject.create();
  private final Observable<${entity.name?cap_first}${entity_suffix}> multicastObservable = newVersionPublishSubject.share();
  
  /**
   * Get the ${entity.name?cap_first}${entity_suffix} observable.
   * @return rxjava Observable of ${entity.name?cap_first}${entity_suffix}
   */
  public Observable<${entity.name?cap_first}${entity_suffix}> getObservable() {
    return multicastObservable;
  }
  </#if>

  /**
   * {@inheritDoc}
   */
  @Override
  public ${entity.name?cap_first} getByPrimaryKey(<#if primaryAttributes?size gt 1>Object[] keys<#else><#list primaryAttributes as attribute>${attribute.type} ${attribute.name?lower_case}<#if attribute?has_next>,</#if></#list></#if>){
    return repository.findById(<#if primaryAttributes?size gt 1>keys<#else><#list primaryAttributes as attribute>${attribute.name?lower_case}<#if attribute?has_next>,</#if></#list></#if>)
			 .map(getTransformerService()::transformEntityToProto)
			 .orElse(null);
  }

  @Override
  public ${entity.name?cap_first} getOne(${entity.name?cap_first} ${entity.name?lower_case}) {
    return getByPrimaryKey(<#list primaryAttributes as attribute>${entity.name?lower_case}.get${attribute.name?cap_first}()<#sep>,</#sep></#list>);
  }

  /**
   * {@inheritDoc}
   */
  @Transactional(readOnly=false) 
  @Override
  public ${entity.name?cap_first}SaveResult save(${entity.name?cap_first} proto) {
      ${entity.name?cap_first}${entity_suffix} entity = new ${entity.name?cap_first}Entity();
      getTransformerService().transformProtoToEntity(proto, entity);

	  <#if entity.hasAnnotation("EXTENDABLE")>
	  // Set schema
	  Optional<SchemaEntity> schemaOptional = schemaDao.findLatestVersionByFqn(proto.getSchemaFullyQualifiedName());
      SchemaEntity schema = schemaOptional.get();
      entity.setSchema(schema);	
      </#if>

      ${entity.name?cap_first}SaveResult.Builder builder = ${entity.name?cap_first}SaveResult.newBuilder();

      Map<String, String> errors = PotValidationUtil.validateDTO(validator, entity);
      notifyAfterValidation(entity, errors);

      // if has javax.validation errors return with FAILURE status
      if (errors != null && errors.size() > 0) {
        builder.setStatus(${entity.name}SaveStatusEnum.FAILURE);
        builder.setEntityProto(proto);
        builder.putAllErrors(errors);
      } else {
        // Notify listeners before save
        notifyBeforeSave(entity);
        // Create audit data
        Auditor auditor = Auditor.current();

        // Set Audit operation type
        auditor.request("save-${entity.name}");
        auditor.operationQualifier("save-${entity.name}");
        Audit audit = auditor.audit();
        
        // Attach audit data to entity
        entity.setAudit(audit.toByteArray());
        // Save entity
        ${entity.name?cap_first}${entity_suffix} savedEntity = repository.save(entity);

        // Notify listeners after save
        notifyAfterSave(savedEntity);

        // Convert result entity to proto 
        builder.setEntityProto(getTransformerService().transformEntityToProto(savedEntity));
      }
    return builder.build();
  }
 
  /**
   * {@inheritDoc}
   */
  @Transactional(readOnly=false)
  @Override
  public void delete(<#if primaryAttributes?size gt 1>Object[] keys<#else><#list primaryAttributes as attribute>${attribute.type} ${attribute.name?lower_case}<#if attribute?has_next>,</#if></#list></#if>){
    repository.deleteById(<#if primaryAttributes?size gt 1>keys<#else><#list primaryAttributes as attribute>${attribute.name?lower_case}<#if attribute?has_next>,</#if></#list></#if>);
  }
 
  /**
   * {@inhertiDoc}
   */
  @Override
  public ResultPage<${entity.name?cap_first}> queryResult(
   String sort,
   Integer page,
   Integer size
   <#if entity.hasAnnotation("AUDIT_AWARE")>, String createdBy, Date createdDate, Date fromCreatedDate, Date toCreatedDate, String modifiedBy, Date modifiedDate, Date fromModifiedDate, Date toModifiedDate</#if>
   <#if searchableAttributes?size gt 0>,</#if>
   <#list searchableAttributes as attribute>
   <#if attribute.type=="Byte" || attribute.type=="Short"|| attribute.type=="Integer"|| attribute.type=="Long"|| attribute.type=="Float"|| attribute.type=="Double"|| attribute.type=="Date">
${attribute.type} from${attribute.name?cap_first},
   ${attribute.type} to${attribute.name?cap_first},
   <#elseif attribute.type = "String" && attribute.location>
   Double ${attribute.name?lower_case}Distance, 
   </#if>
   ${attribute.type} ${attribute.name?lower_case}<#if attribute?has_next>, </#if>
   </#list>
   <#list entity.relations as relation>
   <#list relation.model.getAttributesByAnnotation("PK") as primaryAttribute>
   ,${primaryAttribute.type} ${relation.model.name?uncap_first}${relation.relationName?cap_first}${primaryAttribute.name?cap_first}
   </#list>
   </#list>
   <#list entity.attributes as attribute>
   <#if attribute.reference>
   <#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
   // Query from ${primaryAttribute.type} ${attribute.name} reference.
   ,${convertJavaToObjectType(primaryAttribute.type)} ${attribute.name?uncap_first}${primaryAttribute.name?cap_first}
   </#list>
   </#if>
   </#list>) {
   
    PageRequest pageRequest = null ; 
    // Check the sort parameters
    if(sort != null){
      Sort s = buildSort(sort);
      pageRequest = new PageRequest(page, size, s);
    }else {
      // without sorting
      pageRequest = new PageRequest(page, size);
    }
    ${entity.name?cap_first}Specification ${entity.name?uncap_first}Specification = new ${entity.name?cap_first}Specification(
    <#assign relationAdded = false>
    <#list entity.relations as relation>
    <#list relation.model.getAttributesByAnnotation("PK") as primaryAttribute>
    ${relation.model.name?uncap_first}${relation.relationName?cap_first}${primaryAttribute.name?cap_first}
    <#assign relationAdded = true>
    </#list>
    <#sep>,</#sep>
    </#list>
    <#if searchableAttributes?size gt 0 && relationAdded>,</#if>
    <#list searchableAttributes as attribute>
    <#if attribute.type=="Byte" || attribute.type=="Short"|| attribute.type=="Integer"|| attribute.type=="Long"|| attribute.type=="Float"|| attribute.type=="Double"|| attribute.type=="Date">
    from${attribute.name?cap_first},
    to${attribute.name?cap_first},
    <#elseif attribute.type = "String" && attribute.location>
    ${attribute.name?lower_case}Distance, 
    </#if>
    ${attribute.name?lower_case}<#if attribute?has_next>, </#if>
    </#list>);
    
    <#if entity.hasAnnotation("AUDIT_AWARE")>
    ${entity.name?uncap_first}Specification.setCreatedBy(createdBy);
    ${entity.name?uncap_first}Specification.setCreatedDate(createdDate);
    ${entity.name?uncap_first}Specification.setFromCreatedDate(fromCreatedDate);
    ${entity.name?uncap_first}Specification.setToCreatedDate(toCreatedDate);
    ${entity.name?uncap_first}Specification.setModifiedBy(modifiedBy);
    ${entity.name?uncap_first}Specification.setModifiedDate(modifiedDate);
    ${entity.name?uncap_first}Specification.setFromModifiedDate(fromModifiedDate);
    ${entity.name?uncap_first}Specification.setToModifiedDate(toModifiedDate);
    </#if>
    <#list entity.attributes as attribute>
      <#if attribute.reference>
       <#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
    // Query from ${primaryAttribute.type} ${attribute.name} reference.
    ${entity.name?uncap_first}Specification.set${attribute.name?cap_first}${primaryAttribute.name?cap_first}(${attribute.name?uncap_first}${primaryAttribute.name?cap_first});
       </#list>
      </#if>
     </#list>
    
    // Inject custom constraints
    if (this.queryConstraintListener != null){
      ${entity.name?uncap_first}Specification.setQueryListener(this.queryConstraintListener);
    }
    
    Page<${entity.name?cap_first}${entity_suffix}> entityPage = repository.findAll(${entity.name?uncap_first}Specification,pageRequest);
  
    ResultPage<${entity.name?cap_first}> resultPage = new ResultPage<>();
    List<${entity.name?cap_first}> result = entityPage.getContent().stream()
        .map(e -> getTransformerService().transformEntityToProto(e))
        .collect(Collectors.toList());
        
        resultPage.setList(result);
        resultPage.setTotalElements((int)entityPage.getTotalElements());
        resultPage.setNumber(entityPage.getNumber());
        resultPage.setNumberOfElements(entityPage.getNumberOfElements());
        resultPage.setSize(entityPage.getSize());
        resultPage.setTotalPages(entityPage.getTotalPages());
  
    return resultPage;
   }
 
  @Override
  public ResultPage<${entity.name?cap_first}> quickSearch(String quickSearchQuery, Integer page, Integer size, String sort
   <#list searchableAttributes as attribute>
   <#if attribute.type=="Byte" || attribute.type=="Short"|| attribute.type=="Integer"|| attribute.type=="Long"|| attribute.type=="Float"|| attribute.type=="Double"|| attribute.type=="Date">
   ,${attribute.type} from${attribute.name?cap_first}
   ,${attribute.type} to${attribute.name?cap_first}
   <#elseif attribute.type = "String" && attribute.location>
   ,Double ${attribute.name?lower_case}Distance
   </#if>
   ,${attribute.type} ${attribute.name?lower_case}
   </#list>
   <#list entity.relations as relation>
   <#list relation.model.getAttributesByAnnotation("PK") as primaryAttribute>
   ,${primaryAttribute.type} ${relation.model.name?uncap_first}${relation.relationName?cap_first}${primaryAttribute.name?cap_first}
   </#list>
   </#list>) {
    
    ${entity.name?cap_first}QuickSearchSpecification quickSearchSpec = new ${entity.name?cap_first}QuickSearchSpecification(quickSearchQuery
    
    <#assign relationAdded = false>
    <#list entity.relations as relation>
    <#list relation.model.getAttributesByAnnotation("PK") as primaryAttribute>
    ,${relation.model.name?uncap_first}${relation.relationName?cap_first}${primaryAttribute.name?cap_first}
    <#assign relationAdded = true>
    </#list>
    </#list>
    <#list searchableAttributes as attribute>
    <#if attribute.type=="Byte" || attribute.type=="Short"|| attribute.type=="Integer"|| attribute.type=="Long"|| attribute.type=="Float"|| attribute.type=="Double"|| attribute.type=="Date">
    ,from${attribute.name?cap_first}
    ,to${attribute.name?cap_first}
    <#elseif attribute.type = "String" && attribute.location>
    ,${attribute.name?lower_case}Distance 
    </#if>
    ,${attribute.name?lower_case}
    </#list>);
    
    // Inject custom constraints
    if (this.queryConstraintListener != null){
      quickSearchSpec.setQueryListener(this.queryConstraintListener);
    }
    
    PageRequest pageRequest = null;
    // Check the sort parameters
    if (sort != null) {
      Sort s = buildSort(sort);
      pageRequest = new PageRequest(page, size, s);
    } else {
      // without sorting
      pageRequest = new PageRequest(page, size);
    }
    Page<${entity.name?cap_first}Entity> entityPage = repository.findAll(quickSearchSpec, pageRequest);
    ResultPage<${entity.name?cap_first}> resultPage = new ResultPage<>();
    List<${entity.name?cap_first}> result = entityPage.getContent()
      .stream()
      .map(e -> getTransformerService().transformEntityToProto(e))
      .collect(Collectors.toList());

    resultPage.setList(result);
    resultPage.setTotalElements((int) entityPage.getTotalElements());
    resultPage.setNumber(entityPage.getNumber());
    resultPage.setNumberOfElements(entityPage.getNumberOfElements());
    resultPage.setSize(entityPage.getSize());
    resultPage.setTotalPages(entityPage.getTotalPages());

    return resultPage;
  } 
 
  @Override
  public List<${entity.name?cap_first}> getAll${entity.name?cap_first}s() {
    return repository.findAll()
        .stream()
        .map(e -> getTransformerService().transformEntityToProto(e))
        .collect(Collectors.toList());
  }     
 
  /**
   * {@inhertiDoc}
   */
  @Override
  public ${entity.name?cap_first}${entity_repository_suffix}  getRepository() {
     return repository;
  }
    
  /**
   * {@inheritDoc}
   */
  @Override
  protected String getDefaultTransformerBeanName() {
     return "${entity.name?cap_first}${entity_suffix}Mapper";
  }
 
  /**
   * {@inheritDoc}
   */
  @Override
  protected String getEntityName() {
    return "${entity.name?lower_case}";
  }
 
  <#list entity.attributes as attribute>
   <#if attribute.reference>
   <#if attribute.multiplicity == 1>
  /**
   * {@inhertiDoc}
   */
  @Transactional(readOnly=false)
  public ${entity.name?cap_first} set${attribute.name?cap_first}Relation(
      <#list entity.getAttributesByAnnotation("PK") as primaryAttribute>
        ${primaryAttribute.type} ${primaryAttribute.name}${entity.name},
        </#list>
        <#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
        ${primaryAttribute.type} ${attribute.name}${primaryAttribute.name?cap_first}${attribute.model.name}<#sep>,</#sep>
        </#list>){
        
      // Find entities
      ${entity.name}${entity_suffix} ${entity.name?uncap_first}${entity_suffix} = repository.getOne(<#list entity.getAttributesByAnnotation("PK") as primaryAttribute>${primaryAttribute.name}${entity.name}<#sep>,</#sep></#list>);
      ${attribute.type}${entity_suffix} ${attribute.type?uncap_first}${entity_suffix} = ${attribute.type?uncap_first}Service.getRepository().getOne(<#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>${attribute.name}${primaryAttribute.name?cap_first}${attribute.model.name}<#sep>,</#sep></#list>);
      // Set relation
      ${entity.name?uncap_first}${entity_suffix}.set${attribute.name?cap_first}(${attribute.type?uncap_first}${entity_suffix});
      // Save entity
      ${entity.name?cap_first}${entity_suffix} saved = (${entity.name?cap_first}${entity_suffix}) getRepository().save(${entity.name?uncap_first}${entity_suffix});
      // Return entity saved
      return getTransformerService().transformEntityToProto(saved);
    }
   <#elseif attribute.multiplicity == -1>
  /**
   * {@inhertiDoc}
   */
  @Transactional(readOnly=false)      
  public ${entity.name?cap_first}SaveResult add${attribute.name?cap_first}Relation(
    <#list entity.getAttributesByAnnotation("PK") as primaryAttribute>
    ${primaryAttribute.type} ${primaryAttribute.name}${entity.name},
    </#list>
    <#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
    ${primaryAttribute.type} ${primaryAttribute.name}${attribute.model.name}<#sep>,</#sep>
    </#list>){
     
    ${entity.name?cap_first}${entity_suffix} ${entity.name?uncap_first}${entity_suffix}  = repository.getOne(<#list entity.getAttributesByAnnotation("PK") as primaryAttribute>
    ${primaryAttribute.name}${entity.name}
    </#list>);
    
    ${attribute.type?cap_first}${entity_suffix} ${attribute.type?uncap_first}${entity_suffix} = ${attribute.type?uncap_first}Service.getRepository().getOne(<#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
    ${primaryAttribute.name}${attribute.model.name}<#sep>,</#sep>
    </#list>);
    
    // Validate the relation added
    Map<String, String> errors = new HashMap<>();
    notifyAdd${attribute.name?cap_first}Relation(${entity.name?uncap_first}${entity_suffix}, ${attribute.type?uncap_first}${entity_suffix}, errors);
    
    ${entity.name?cap_first}SaveResult.Builder builder = ${entity.name?cap_first}SaveResult.newBuilder();
    if(errors.size() > 0){
      builder.setStatus(${entity.name}SaveStatusEnum.FAILURE);
      builder.putAllErrors(errors);
    } else {
      builder.setStatus(${entity.name}SaveStatusEnum.SUCCESS);
      ${entity.name?uncap_first}${entity_suffix}.add${attribute.name?cap_first}(${attribute.type?uncap_first}${entity_suffix});
      ${attribute.type?uncap_first}Service.getRepository().save(${attribute.type?uncap_first}${entity_suffix});
      // Publish the relation
      AddLink${entity.name?cap_first}To${attribute.name?cap_first}Request link = AddLink${entity.name?cap_first}To${attribute.name?cap_first}Request.newBuilder()
        .setLink(true) 
      <#list entity.getAttributesByAnnotation("PK") as primaryAttribute>
        .set${primaryAttribute.name?cap_first}(${primaryAttribute.name}${entity.name})
      </#list>
      <#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
        .set${attribute.name?cap_first}${primaryAttribute.name?cap_first}(${primaryAttribute.name}${attribute.model.name})
      </#list> 
        .build();
      // Publish  
      addLink${entity.name?cap_first}To${attribute.name?cap_first}Subject.onNext(link);
    }
    return builder.build();
  }
  
  /**
   * {@inhertiDoc}
   */
  @Transactional(readOnly=false)     
  public ${entity.name?cap_first}SaveResult remove${attribute.name?cap_first}Relation(
    <#list entity.getAttributesByAnnotation("PK") as primaryAttribute>
    ${primaryAttribute.type} ${primaryAttribute.name}${entity.name},
    </#list>
    <#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
    ${primaryAttribute.type} ${primaryAttribute.name}${attribute.model.name}<#sep>,</#sep>
    </#list>){

    ${entity.name?cap_first}${entity_suffix} ${entity.name?uncap_first}${entity_suffix}  = repository.getOne(<#list entity.getAttributesByAnnotation("PK") as primaryAttribute>
    ${primaryAttribute.name}${entity.name}
    </#list>);
    ${attribute.type?cap_first}${entity_suffix} ${attribute.type?uncap_first}${entity_suffix} = ${attribute.type?uncap_first}Service.getRepository().getOne(<#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
    ${primaryAttribute.name}${attribute.model.name}<#sep>,</#sep>
    </#list>);
    
    // Validate the relation removed
    Map<String, String> errors = new HashMap<>();
    notifyRemove${attribute.name?cap_first}Relation(${entity.name?uncap_first}${entity_suffix}, ${attribute.type?uncap_first}${entity_suffix}, errors);
    
    ${entity.name?cap_first}SaveResult.Builder builder = ${entity.name?cap_first}SaveResult.newBuilder();
    if(errors.size() > 0){
      builder.setStatus(${entity.name}SaveStatusEnum.FAILURE);
      builder.putAllErrors(errors);
    } else {
      builder.setStatus(${entity.name}SaveStatusEnum.SUCCESS);
      ${entity.name?uncap_first}${entity_suffix}.remove${attribute.name?cap_first}(${attribute.type?uncap_first}${entity_suffix});
      ${attribute.type?uncap_first}Service.getRepository().save(${attribute.type?uncap_first}${entity_suffix});
      // Publish the relation
      AddLink${entity.name?cap_first}To${attribute.name?cap_first}Request link = AddLink${entity.name?cap_first}To${attribute.name?cap_first}Request.newBuilder()
        .setLink(false) 
      <#list entity.getAttributesByAnnotation("PK") as primaryAttribute>
        .set${primaryAttribute.name?cap_first}(${primaryAttribute.name}${entity.name})
      </#list>
      <#list attribute.model.getAttributesByAnnotation("PK") as primaryAttribute>
        .set${attribute.name?cap_first}${primaryAttribute.name?cap_first}(${primaryAttribute.name}${attribute.model.name})
      </#list> 
        .build();
      // Publish  
      addLink${entity.name?cap_first}To${attribute.name?cap_first}Subject.onNext(link);
    }
    return builder.build();
  } 
        <#else>
    // UNKOWN attribute (${attribute.name}) multiplicity = ${attribute.multiplicity}
        </#if>
   </#if>
 </#list>
   
  /**
   * {@inheritDoc}
   */
  @Override
  protected void onBeforeSave(${entity.name?cap_first} dto, ${entity.name?cap_first}${entity_suffix} entity) {
  }
    
  /**
   * {@inheritDoc}
   */
  @Override
  protected void onSave(${entity.name?cap_first} dto, ${entity.name?cap_first}${entity_suffix} entity) {
  }

  @Override
  protected void getEntityConvertedFromDTO(${entity.name?cap_first} dto, ${entity.name?cap_first}${entity_suffix} entity) {
     // TODO
  }

  @Override
  protected void getDTOConvertedFromEntity(${entity.name?cap_first}${entity_suffix} entity, ${entity.name?cap_first} dto) {
     // TODO
  }

  @Override
  protected ${entity.name?cap_first}${entity_suffix} getNewEntityInstance() {
    return new ${entity.name?cap_first}${entity_suffix}();
  }
  
  /**
   * Parse the params string and return a Sort object that 
   * contains all the sort parameters.
   */
  private Sort buildSort(String sort) {
    List<Order> orders = new ArrayList<>();
    String[] values = sort.split(",");
    for(int i=0; i< values.length-1; i=i+2){
      String column = values[i];
      String direction = values[i+1];
      Order columnSort = new Order(Direction.fromString(direction), column);
      orders.add(columnSort);
    }
    return new Sort(orders);
  }
  
  /**
   * Notify all validation listeners.
   * @param entity Entity to validated
   * @param errors map of errors
   */
  private void notifyAfterValidation(${entity.name?cap_first}Entity entity, final Map<String, String> errors) {
    validationListeners.forEach(listener -> listener.onAfterValidation(entity, errors));
  }
  
  /**
   * {@inheritDoc}
   */
  @Override
  public void register${entity.name?cap_first}ValidationListener(${entity.name?cap_first}ValidationListener listener){
    this.validationListeners.add(listener);
  }
  
  <#list entity.attributes as attribute>
   <#if attribute.reference>
  /**
   * Notify all the validation listeners.
   * @param ${entity.name?uncap_first}Entity
   * @param ${attribute.type?uncap_first}Entity
   * @param errors
   */
  private void notifyRemove${attribute.name?cap_first}Relation(${entity.name?cap_first}Entity ${entity.name?uncap_first}Entity, ${attribute.type?cap_first}Entity ${attribute.type?uncap_first}Entity, Map<String, String> errors) {
    validationListeners.forEach(listener -> listener.onRemove${attribute.name?cap_first}Relation(${entity.name?uncap_first}Entity, ${attribute.type?uncap_first}Entity, errors));
  }
  
  /**
   * Notify all the validation listeners.
   * @param ${entity.name?uncap_first}Entity
   * @param ${attribute.type?uncap_first}Entity
   * @param errors
   */
  private void notifyAdd${attribute.name?cap_first}Relation(${entity.name?cap_first}Entity ${entity.name?uncap_first}Entity, ${attribute.type?cap_first}Entity ${attribute.type?uncap_first}Entity, Map<String, String> errors) {
    validationListeners.forEach(listener -> listener.onAdd${attribute.name?cap_first}Relation(${entity.name?uncap_first}Entity, ${attribute.type?uncap_first}Entity, errors));
  }
    
   </#if>
  </#list>
  
  /**
   * {@inheritDoc}
   */
  @Override
  public void register${entity.name?cap_first}ServiceListener(${entity.name?cap_first}ServiceListener listener){
    this.serviceListeners.add(listener);
  }
  
  /**
   * Register query constraint listener.
   */
  public void register${entity.name?cap_first}QueryConstraintListener(${entity.name?cap_first}QueryConstraintListener listener){
    this.queryConstraintListener = listener;
  }
  
  /**
   * Notify all service listeners before service.
   * @param entity Entity to be saved.
   */
  private void notifyBeforeSave(${entity.name?cap_first}Entity entity) {
    serviceListeners.forEach(listener -> listener.onBeforeSave(entity));
  }
  
  /**
   * Notify all service listeners after saving.
   * @param entity Entity saved.
   */
  private void notifyAfterSave(${entity.name?cap_first}Entity entity) {
    <#if entity.hasAnnotation("PUBLISH")>
    // Push to subject
    this.newVersionPublishSubject.onNext(entity);
    </#if>
    // TODO to remove and use the Subject
    // Push to internal listeners
    serviceListeners.forEach(listener -> listener.onAfterSave(entity));
  }

}