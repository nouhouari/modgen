<#macro underlinesToCamelCase inString><#local strArray = inString?split("_")><#list strArray as item><#if item?index == 0>${item}<#else>${item?cap_first}</#if></#list></#macro>
<#assign aDateTime = .now>
<#assign aDate = aDateTime?date>
/*
 * 
 * Nourreddine HOUARI CONFIDENTIAL
 * 
 * All information contained herein is, and remains
 * the property of Nourreddine HOUARI and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Nourreddine HOUARI
 * and its suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Nourreddine HOUARI.
 * 
 * [2017] Nourreddine HOUARI SA
 * All Rights Reserved.
 */

/*
 * Author   : Nourreddine HOUARI <nourreddine.houari@>
 *      Koneru, Venkaiah Chowdary <VenkaiahChowdary.Koneru@> 
 *
 * Date     :  ${aDate?string.medium} 
 * 
 * File     :  ${entity.name?cap_first}.java 
 * 
 * Copyright (c) ${aDate?string.yyyy} houari_nourreddine Sdn Bhd, All rights reserved.                   
 */
 
package ${package};
<#function convertKeyValue type key value>
  <#if key="value">
  <#if type="Integer" || type="int" || 
  type="Long" || type="long" || 
  type="Byte" || type="byte" ||
  type="Short" || type="short">
    <#return "${key}=${value}">
  <#else>
    <#return "${key}=\"${value}\"">
  </#if>
  <#else>
  <#return "${key}=\"${value}\"">
  </#if>
</#function>

<#list imports as imp>
${imp}
</#list>
import ${package}.EntityState;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import javax.validation.constraints.*;
import javax.persistence.Transient;
import javax.persistence.Embedded;
import org.hibernate.annotations.GenericGenerator;

import lombok.Data;
import lombok.NoArgsConstructor;
<#if entity.hasOneOfAnnotation(["AUDIT_AWARE", "SYNCH_SERVER", "SYNCH_CLIENT"])>
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
</#if>
<#if entity.hasAnnotation("EXTENDABLE")>
import lombok.NonNull;
import org.hibernate.annotations.Parameter;
import org.hibernate.annotations.TypeDef;
</#if>

/**
 * THIS FILE IS AUTOMATICALLY GENERATED
 *     >> DO NOT EDIT MANUALLY <<
 * <br><br>
 * Generated by : ${generator}<br>
 * Version      : ${version}<br>
 * Date         : ${aDate?string.medium}<br>
 * <br>
 * @author Nourreddine HOUARI nourreddine.houari@
 * @author Koneru, Venkaiah Chowdary VenkaiahChowdary.Koneru@
 *
 */
@Entity
@Table(name = "${entity.name}${entity_suffix}")
@Data
@NoArgsConstructor
<#if entity.hasOneOfAnnotation(["AUDIT_AWARE", "SYNCH_SERVER", "SYNCH_CLIENT"])>
@EntityListeners(AuditingEntityListener.class)
</#if>
public class ${entity.name}${entity_suffix} { 
 
  <#list entity.attributes as attribute>
  // ${attribute}
  <#if attribute.hasValidations()>
  <#list attribute.getAnnotationGroups()["VALIDATIONS"] as va>
  @${va.getName()}(<#list va.getDetails()?keys as k>${convertKeyValue(attribute.type,k,va.getDetails()[k])}<#if k_has_next>,</#if></#list>)
  </#list>
  </#if>
  <#if attribute.reference>
  // multiplicity : ${attribute.multiplicity} opposite: ${attribute.oppositeMultiplicity}
  <#if attribute.multiplicity==1 && attribute.oppositeMultiplicity==1>
  @OneToOne(fetch = FetchType.EAGER <#if attribute.hasAnnotation("ALLOW_CASCADE")>, cascade = CascadeType.ALL</#if>)
  private ${attribute.type}${entity_suffix} ${attribute.name};
  
  <#elseif attribute.multiplicity==1 && attribute.oppositeMultiplicity==-1>
  @ManyToOne(fetch = FetchType.EAGER)
  private ${attribute.type}${entity_suffix} ${attribute.name};
 
   <#elseif attribute.oppositeMultiplicity==1>
  @OneToMany(fetch = FetchType.LAZY, mappedBy = "${entity.name?uncap_first}_${attribute.name?uncap_first}", cascade = CascadeType.ALL)  
  private List<${attribute.type}${entity_suffix}> ${attribute.name};
 
   <#else>
  @ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
  private List<${attribute.type}${entity_suffix}> ${attribute.name};
 
  </#if>
  <#elseif attribute.enumerate>
  @Column(name = "${attribute.name?uncap_first}")
  @Enumerated(EnumType.STRING)
  private ${attribute.type} ${attribute.name};
 
  <#elseif attribute.type == "Date">
  @Column(name = "${attribute.name?uncap_first}")
  @Temporal(TemporalType.TIMESTAMP)
  private ${attribute.type} ${attribute.name};
 
  <#else>
  <#if attribute.hasAnnotation("PK")>
  @Column(name = "${attribute.name?lower_case}")
  @Id
  <#if attribute.hasAnnotation("AUTO")>
  // Auto detected
  <#if attribute.type == "Integer" || attribute.type == "Long" || attribute.type == "int" || attribute.type == "long">
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "${entity.name?lower_case}${entity_suffix?lower_case}_seq_gen")
  @SequenceGenerator(name = "${entity.name?lower_case}${entity_suffix?lower_case}_seq_gen", sequenceName = "${entity.name?lower_case}${entity_suffix?lower_case}_seq")
  <#elseif attribute.type == "String">
  @GeneratedValue(generator = "uuid2")
  @GenericGenerator(name="uuid2", strategy = "uuid2")
  </#if>
  </#if>
  private ${attribute.type} ${attribute.name};
  
  <#else>
  <#if attribute.type=="String" && attribute.hasAnnotation("LONG")>
  <#if attribute.getAnnotation("LONG").hasDetail("LENGTH")>
  @Column(name = "${attribute.name?uncap_first}", length = ${attribute.getAnnotation("LONG").getDetailValue("LENGTH")})
  <#else>
  @Column(columnDefinition = "text")
  </#if>
  private ${attribute.type} ${attribute.name};
 
  <#elseif attribute.type=="String" && attribute.hasAnnotation("LOCATION")>
  @Column(columnDefinition = "geography")
  private Point ${attribute.name};
 
  <#else>
  @Column(name = "${attribute.name?uncap_first}")
  @Basic
  private ${attribute.type} ${attribute.name};
 
  </#if>
  </#if>
  </#if>
  </#list>
  <#list entity.relations as relation>
  <#if relation.multiplicity=1>
  <#elseif relation.oppositeMultiplicity=1>
  @ManyToOne(fetch=FetchType.EAGER)
  @JoinColumn(name="${relation.model.name?uncap_first}_${relation.relationName?lower_case}_fk")
  @JsonManagedReference
  private ${relation.model.name}${entity_suffix} ${relation.model.name?uncap_first}_${relation.relationName?uncap_first};
  
  <#else>
  @ManyToMany(fetch=FetchType.LAZY, mappedBy="${relation.relationName}")
  @JsonManagedReference
  private List<${relation.model.name}${entity_suffix}> ${relation.model.name?uncap_first}_${relation.relationName?uncap_first};
  
  </#if>
  </#list>
  <#if entity.hasOneOfAnnotation(["AUDIT_AWARE", "SYNCH_SERVER", "SYNCH_CLIENT"])>
  @Column(name = "createdDate", nullable = false, updatable = false)
  @Temporal(TemporalType.TIMESTAMP)
  @CreatedDate
  private Date createdDate;

  @Column(name = "modifiedDate")
  @Temporal(TemporalType.TIMESTAMP)
  @LastModifiedDate
  private Date modifiedDate;

  @Column(name = "createdBy")
  @CreatedBy
  private String createdBy;

  @Column(name = "modifiedBy")
  @LastModifiedBy
  private String modifiedBy;
  </#if>
  <#if entity.hasAnnotation("VERSIONABLE")>
  <#if owner>
  @Version
  </#if>
  @Column(name = "version")
  private Long version;
  </#if>
  <#if entity.hasAnnotation("PUBLISH")>
  /**
   * Publish entity flag.
   */
  private boolean published;
  </#if>
  <#if entity.hasAnnotation("EXTENDABLE")>
  @Embedded
  private Extension extension;
  </#if>
  
  <#list entity.attributes as attribute>
  <#if attribute.reference && attribute.multiplicity=-1>
  <#if attribute.oppositeMultiplicity==1 >
  /**
   * OneToMany to many attribute.
   * Add to ${attribute.name} list.
   * @param ${attribute.type?uncap_first}
   */
  public void add${attribute.name?cap_first}(${attribute.type}${entity_suffix} ${attribute.type?uncap_first}) {
    if (this.${attribute.name} == null) {
      this.${attribute.name} = new ArrayList<>();
    }
    this.${attribute.name}.add(${attribute.type?uncap_first});
    ${attribute.type?uncap_first}.set${entity.name?cap_first}_${attribute.name?uncap_first}(this);
  }

  /**
   * OneToMany to many attribute.
   * Remove from ${attribute.name} list.
   * @param ${attribute.type?uncap_first}
   */
  public void remove${attribute.name?cap_first}(${attribute.type}${entity_suffix} ${attribute.type?uncap_first}) {
    if (this.${attribute.name} != null) {
      this.${attribute.name}.remove(${attribute.type?uncap_first});
    }
    ${attribute.type?uncap_first}.set${entity.name?cap_first}_${attribute.name?uncap_first}(null);
  }
  <#else>
  /**
   * ManyToMany to many attribute.
   * Add to ${attribute.name} list.
   * @param ${attribute.type?uncap_first}
   */
  public void add${attribute.name?cap_first}(${attribute.type}${entity_suffix} ${attribute.type?uncap_first}) {
    if (this.${attribute.name} == null) {
      this.${attribute.name} = new ArrayList<>();
    }
    this.${attribute.name}.add(${attribute.type?uncap_first});
    //${attribute.type?uncap_first}.add${attribute.name?cap_first}(this);
  }

  /**
   * ManyToMany to many attribute.
   * Remove from ${attribute.name} list.
   * @param ${attribute.type?uncap_first}
   */
  public void remove${attribute.name?cap_first}(${attribute.type}${entity_suffix} ${attribute.type?uncap_first}) {
    if (this.${attribute.name} != null) {
      this.${attribute.name}.remove(${attribute.type?uncap_first});
    }
    //${attribute.type?uncap_first}.remove${attribute.name?cap_first}(null);
  }
  </#if>
  </#if>
  </#list>
  
  <#list entity.relations as relation>
  <#if relation.oppositeMultiplicity==-1>
  /**
   * Many to many relation.
   * Add to ${relation.relationName} list.
   */
  public void add${relation.relationName?cap_first}(${relation.model.name}${entity_suffix} ${relation.model.name?uncap_first}) {
    if (${relation.model.name?uncap_first}_${relation.relationName?uncap_first} == null) {
      this.${relation.model.name?uncap_first}_${relation.relationName?uncap_first} = new ArrayList<>();
    }
    this.${relation.model.name?uncap_first}_${relation.relationName?uncap_first}.add(${relation.model.name?uncap_first});
    //${relation.model.name?uncap_first}.add${relation.relationName?cap_first}(this);
  }

  /**
   * Many to many relation.
   * Remove from ${relation.relationName} list.
   * @param ${relation.model.name?uncap_first}
   */
  public void remove${relation.relationName?cap_first}(${relation.model.name}${entity_suffix} ${relation.model.name?uncap_first}) {
    if (this.${relation.model.name?uncap_first}_${relation.relationName?uncap_first} != null) {
      this.${relation.model.name?uncap_first}_${relation.relationName?uncap_first}.remove(${relation.model.name?uncap_first});
    }
    //${relation.model.name?uncap_first}.remove${relation.relationName?cap_first}(null);
  }
  </#if>
  </#list>
}
